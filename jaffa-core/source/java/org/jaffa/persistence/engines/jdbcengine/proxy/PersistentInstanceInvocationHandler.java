/*
 * ====================================================================
 * JAFFA - Java Application Framework For All
 *
 * Copyright (C) 2002 JAFFA Development Group
 *
 *     This library is free software; you can redistribute it and/or
 *     modify it under the terms of the GNU Lesser General Public
 *     License as published by the Free Software Foundation; either
 *     version 2.1 of the License, or (at your option) any later version.
 *
 *     This library is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *     Lesser General Public License for more details.
 *
 *     You should have received a copy of the GNU Lesser General Public
 *     License along with this library; if not, write to the Free Software
 *     Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Redistribution and use of this software and associated documentation ("Software"),
 * with or without modification, are permitted provided that the following conditions are met:
 * 1.	Redistributions of source code must retain copyright statements and notices.
 *         Redistributions must also contain a copy of this document.
 * 2.	Redistributions in binary form must reproduce the above copyright notice,
 * 	this list of conditions and the following disclaimer in the documentation
 * 	and/or other materials provided with the distribution.
 * 3.	The name "JAFFA" must not be used to endorse or promote products derived from
 * 	this Software without prior written permission. For written permission,
 * 	please contact mail to: jaffagroup@yahoo.com.
 * 4.	Products derived from this Software may not be called "JAFFA" nor may "JAFFA"
 * 	appear in their names without prior written permission.
 * 5.	Due credit should be given to the JAFFA Project (http://jaffa.sourceforge.net).
 *
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
 * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
 * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * ====================================================================
 */

package org.jaffa.persistence.engines.jdbcengine.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.*;
import org.jaffa.datatypes.*;
import org.jaffa.metadata.*;
import org.jaffa.rules.RulesEngine;
import org.jaffa.persistence.exceptions.*;
import org.jaffa.exceptions.FrameworkException;
import org.jaffa.persistence.IPersistent;
import org.jaffa.persistence.engines.jdbcengine.configservice.ClassMetaData;
import org.jaffa.persistence.engines.jdbcengine.configservice.ConfigurationService;
import org.jaffa.persistence.util.PersistentHelper;

/** This is the InvocationHandler implemenation for the proxy class generated by the PersistentInstanceFactory.
 * It delegates all IPersistent calls to an instance of the PersistentInstanceDelegate.
 * It maintains all the fields of the actual persistent class in a Map and all the getters and setters simply manipulate that map.
 */
class PersistentInstanceInvocationHandler implements InvocationHandler {

    private Class m_actualPersistentClass = null;
    private PersistentDelegate m_persistentDelegate = new PersistentDelegate();
    private Map m_fields = new HashMap();

    /** Creates an instance of the PersistentInstanceInvocationHandler.
     * @param actualPersistentClass The actual class for which the Proxy is being generated.
     */
    PersistentInstanceInvocationHandler(Class actualPersistentClass) {
        m_actualPersistentClass = actualPersistentClass;
    }

    /** Processes a method invocation on a proxy instance and returns the result.
     * @param proxy the proxy instance that the method was invoked on.
     * @param method the Method instance corresponding to the interface method invoked on the proxy instance.
     * @param args an array of objects containing the values of the arguments passed in the method invocation on the proxy instance.
     * @return the value to return from the method invocation on the proxy instance.
     * @throws Throwable the exception to throw from the method invocation on the proxy instance.
     */
    public Object invoke(Object proxy, Method method, Object[] args)
    throws Throwable {
        try {
            Object output = null;
            stampProxyOnPersistentDelegate(proxy);
            Class declaringClass = method.getDeclaringClass();
            if (declaringClass == IPersistent.class) {
                // Invoke methods on the Persistent instance
                output = proxyPersistent(method, args);
            } else if (declaringClass == Object.class) {
                // Handle the non-final methods of the Object class
                String methodName = method.getName();
                if (methodName.equals("toString")) {
                    output = proxyToString();
                } else if (methodName.equals("hashCode")) {
                    output = proxyHashCode();
                } else if (methodName.equals("equals") && args.length == 1) {
                    output = proxyEquals(proxy, args[0]);
                } else {
                    throw new RuntimeException("Cannot handle the method " + method);
                }
            } else {
                String methodName = method.getName();
                if (methodName.startsWith("get")) {
                    String fieldName = methodName.substring("get".length());
                    output = proxyGet(fieldName);
                } else if (methodName.startsWith("is")) {
                    String fieldName = methodName.substring("is".length());
                    output = proxyGet(fieldName);
                } else if (methodName.startsWith("set") && args.length == 1) {
                    String fieldName = methodName.substring("set".length());
                    proxySet(fieldName, args[0], (IPersistent) proxy);
                } else if (methodName.startsWith("update") && args.length == 1) {
                    String fieldName = methodName.substring("update".length());
                    proxyUpdate(fieldName, args[0], (IPersistent) proxy);
                } else if (methodName.startsWith("validate") && args.length == 1) {
                    String fieldName = methodName.substring("validate".length());
                    proxyValidate(fieldName, args[0], (IPersistent) proxy);
                } else {
                    throw new RuntimeException("Cannot handle the method " + method);
                }
            }
            return output;
        } catch (InvocationTargetException e) {
            throw e.getCause() != null ? e.getCause() : e;
        }
    }


    /** Stamps the proxy instance on the persistent delegate. */
    private void stampProxyOnPersistentDelegate(Object proxy) {
        if (m_persistentDelegate.m_proxy == null)
            m_persistentDelegate.m_proxy = (IPersistent) proxy;
    }



    // *****************************************************************
    // ******** PROXY METHODS FOR THE IPersistent Interface ************
    // *****************************************************************
    /** Invokes calls on the persistent delegate. */
    private Object proxyPersistent(Method method, Object[] args) throws Throwable {
        return method.invoke(m_persistentDelegate, args);
    }




    // *****************************************************************
    // ******** PROXY METHODS FOR THE Object CLASS *********************
    // *****************************************************************
    /** The handler for the toString() method. */
    private String proxyToString() {
        StringBuffer buf = new StringBuffer();
        buf.append("<DomainClassName>"); buf.append(m_actualPersistentClass.getName()); buf.append("</DomainClassName>");
        buf.append(m_persistentDelegate.toString());
        buf.append(m_fields);
        return buf.toString();
    }

    /** The handler for the hashCode() method. */
    private Integer proxyHashCode() {
        return new Integer(m_actualPersistentClass.hashCode() + m_persistentDelegate.hashCode() + m_fields.hashCode());
    }

    /** The handler for the equals() method. */
    private Boolean proxyEquals(Object proxy, Object other) {
        return proxy == other ? Boolean.TRUE : Boolean.FALSE;
    }




    // *****************************************************************
    // ******** PROXY METHODS FOR THE ACTUAL PERSISTENT CLASS **********
    // *****************************************************************
    /** The handler for the getXyz() method. */
    private Object proxyGet(String fieldName) {
        return m_fields.get(fieldName);
    }

    /** The handler for the setXyz() method. */
    private void proxySet(String fieldName, Object value, IPersistent persistentObject)
    throws ValidationException, UpdatePrimaryKeyException, ReadOnlyObjectException, AlreadyLockedObjectException, FrameworkException {
        // ignore, if the current value and new value are the same
        Object currentValue = proxyGet(fieldName);
        if (currentValue == null ? value == null : currentValue.equals(value))
            return;

        // do not update a key field, if its a database occurence.
        if (isKeyField(fieldName, persistentObject) && m_persistentDelegate.isDatabaseOccurence())
            throw new UpdatePrimaryKeyException();

        proxyValidate(fieldName, value, persistentObject);
        m_persistentDelegate.invokeUpdate();
        m_persistentDelegate.invokeAddInitialValue(fieldName, currentValue);
        m_fields.put(fieldName, value);
    }

    /** The handler for the updateXyz() method.
     * This is for backwards compatibilty and merely invokes the proxySet() method.
     */
    private void proxyUpdate(String fieldName, Object value, IPersistent persistentObject)
    throws ValidationException, UpdatePrimaryKeyException, ReadOnlyObjectException, AlreadyLockedObjectException, FrameworkException {
        proxySet(fieldName, value, persistentObject);
    }

    /** The handler for the validateXyz() method. */
    private void proxyValidate(String fieldName, Object value, IPersistent persistentObject)
    throws ValidationException, FrameworkException {
        // Invokes the validate method on the FieldValidator
        invokeFieldValidator(fieldName, value, persistentObject);

        // Invoke the Dynamic Rules Engine
        RulesEngine.doAllValidationsForDomainField(m_actualPersistentClass.getName(), fieldName, value, m_persistentDelegate.getUOW());
    }

    /** Returns true if the field is a key */
    private boolean isKeyField(String fieldName, IPersistent persistentObject) {
        ClassMetaData classMetaData = ConfigurationService.getInstance().getMetaData(PersistentInstanceFactory.getActualPersistentClass(persistentObject).getName());
        return classMetaData.isKeyField(fieldName);
    }

    /** Invokes FieldValidator.validate(value, MetaClass.META_FIELD_NAME, true).
     */
    private void invokeFieldValidator(String fieldName, Object value, IPersistent persistentObject)
    throws ValidationException, FrameworkException {
        Class domainClass = PersistentInstanceFactory.getActualPersistentClass(persistentObject);

        try {
            // Determine the datatype for the fieldName from the ClassMetaData
            ClassMetaData classMetaData = ConfigurationService.getInstance().getMetaData(domainClass.getName());
            String type = classMetaData.getType(fieldName);

            if (type == null) { // MetaClass doesn't exist. Do nothing
                return;
            }
            Class clazz = type.equals("byte[]") ? byte[].class : Class.forName(type);

            // Determine the FieldMetaData class
            FieldMetaData fieldMetaData = PersistentHelper.getFieldMetaData(domainClass.getName(), fieldName);

            // Get a handle on the method 'public static void validate(Object, FieldMetaData, boolean)' of the FieldValidator class
            Method m = FieldValidator.class.getMethod("validate",  new Class[] {clazz, fieldMetaData.getClass(), Boolean.TYPE});

            // Now invoke the method
            m.invoke(null, new Object[] {value, fieldMetaData, Boolean.TRUE});
        } catch (ClassNotFoundException e) {
            // MetaClass doesn't exist. Do nothing
        } catch (NoSuchMethodException e) {
            // Method 'public static FieldMetaData getFieldMetaData(String fieldName)' doesn't exist. Do nothing
        } catch (InvocationTargetException e) {
            if (e.getCause() != null) {
                if (e.getCause() instanceof ValidationException)
                    throw (ValidationException) e.getCause();
                else if (e.getCause() instanceof FrameworkException)
                    throw (FrameworkException) e.getCause();
            }
            throw new ProxyFieldValidatoRuntimeException("Exception thrown when validating " + fieldName + " having the value " + value, e);
        } catch (Exception e) {
            throw new ProxyFieldValidatoRuntimeException("Exception thrown when validating " + fieldName + " having the value " + value, e);
        }
    }

    /** This is exclusively for use by the PersistentInstanceFactory.
     * This will merely add the attribute/value to the Map.
     * This will bypass the validations performed during invocation of the setXyz() method on the persistent object.
     * @param attributeName The attribute whose value will be set.
     * @param value The value to be set.
     */
    void addAttributeValue(String attributeName, Object value) {
        m_fields.put(attributeName, value);
    }

}
